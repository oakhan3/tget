#!/usr/bin/env python

# -*- coding: utf-8 -*-

from __future__ import print_function

import argparse
import functools
import io
import json
import os
import re
import sys

if sys.version_info[0] < 3:
    import ConfigParser as configparser

    input = raw_input  # noqa:F821
else:
    import configparser

    unicode = str


# Dirs
HOME_DIR = os.path.expanduser("~")
CONFIG_DIR = os.path.join(HOME_DIR, ".tget")
CONFIG = os.path.join(CONFIG_DIR, "config.cfg")
STORE = os.path.join(CONFIG_DIR, "store.json")

config = configparser.SafeConfigParser()
config.read(CONFIG)


# Internal Functions
def _safe_write(data):
    with io.open(STORE, "w", encoding="utf8") as outfile:
        data_str = json.dumps(data, indent=4, separators=(",", ": "))
        outfile.write(unicode(data_str))


def _access_store(fn):
    """Add a `data` positional arg to the decorated function.
    """

    @functools.wraps(fn)
    def wrapped(*args, **kwargs):
        if not os.path.exists(STORE):
            _safe_write({})

        try:
            with open(STORE) as file_:
                data = json.load(file_)
        except ValueError:
            _echo("Unable to access the `store` - the file may be corrupted!", pre_nl=True)
            _echo("To recreate it anew, run the `tg reset` command.")
            _echo("Store location: {}".format(STORE))
            sys.exit(1)

        return fn(data, *args, **kwargs)

    return wrapped


def _echo(value, pre_nl=False, post_nl=True, flush=False):
    if pre_nl:
        print("echo")

    print('echo "' + value + '"')

    if post_nl:
        print("echo")

    if flush:
        sys.stdout.flush()


def _echo_help(parser):
    parser.print_help = lambda: _echo(parser.format_help())


# Top-Level Functions
@_access_store
def ls(data):
    DIVIDER = "-" * 40

    _echo("")

    for key, value in data.items():
        _echo(key, post_nl=False)
        _echo(DIVIDER)
        _echo(value)
        _echo("")


@_access_store
def get(data, key, execute, priority_vars):
    value = data.get(key)

    if value is None:
        _echo("Nothing found", pre_nl=True)
        sys.exit(1)

    value_placeholders = set(re.findall(r"\$\w+", value))

    try:
        priority_var_map = dict(priority_var.split("=", 1) for priority_var in priority_vars)
    except ValueError:
        _echo("Passed in ENV-VARs must be in the 'ENVVAR=value' form.")
        sys.exit(1)

    for value_placeholder in value_placeholders:
        no_dollar_value_placeholder = value_placeholder[1:]

        if no_dollar_value_placeholder in priority_var_map:
            value = value.replace(value_placeholder, priority_var_map[no_dollar_value_placeholder])
            continue

        if no_dollar_value_placeholder in os.environ:
            value = value.replace(value_placeholder, os.environ[no_dollar_value_placeholder])

    _echo(value, pre_nl=True)

    if execute:
        print(value)


@_access_store
def put(data, key, value):
    if key is None:
        _echo("Key: ", pre_nl=True, post_nl=False, flush=True)
        key = input()

    if not key:
        _echo("Bad Key!", pre_nl=True)
        sys.exit(1)

    if value is None:
        _echo("Value: (Hit <ENTER> twice to end input)", pre_nl=True, post_nl=True, flush=True)
        value = ""
        current_value = None
        previous_value = None
        while True:
            if current_value == "" and previous_value == "":
                break

            current_value = input()
            value += current_value
            value += "\n"
            previous_value = current_value

        # Remove `\n\n` from the value.
        value = value[:-2]

    if not value:
        _echo("Bad Value!")
        sys.exit(1)

    data[key] = value.strip()

    _safe_write(data)

    _echo("STORED")


@_access_store
def delete(data, key):
    try:
        value = data.pop(key)
    except KeyError:
        _echo("Nothing found", pre_nl=True)
        sys.exit(1)

    _safe_write(data)

    _echo("The following was deleted:", pre_nl=True)
    _echo("Key: " + key)
    _echo("Value:\n " + value)


def reset():
    _echo(
        "This will ERASE any currently stored data, type 'RESET' to confirm: ", pre_nl=True, post_nl=False, flush=True
    )

    value = input()

    if value == "RESET":
        _safe_write({})
        _echo("Deleted all stored key-value pairs.", pre_nl=True)
    else:
        _echo("Aborted.", pre_nl=True)

# Individual GET Parser
get_parser = argparse.ArgumentParser(prog="tg", description=description)
get_parser.add_argument("key", metavar="KEY")
get_parser.add_argument(
    "-e", "--exec", help="Execute the retrieved value in the current shell.", dest="execute", action="store_true"
)
get_parser.add_argument(
    "priority_vars",
    metavar="ENVVAR=value",
    nargs="*",
    help="Optional Environment Variables to interpolate into the output.",
)

# Main Parser
parser = argparse.ArgumentParser(prog="tg", description=description)
sub_parsers = parser.add_subparsers(metavar="command")

# GET: This sub-parser is never actually used, it only serves to automatically produce documentation for the main parser.
key_parser = sub_parsers.add_parser("KEY", help="Retrieve the key's value.")
key_parser.add_argument("key")
key_parser.add_argument("-e", "--exec", help="Execute the retrieved value in the current shell.")
key_parser.add_argument(
    "priority_vars",
    metavar="ENVVAR=value",
    nargs="*",
    help="Optional Environment Variables to interpolate into the output.",
)

# PUT
put_parser = sub_parsers.add_parser("put", help="Store a new key-value pair.")
put_parser.add_argument("--key", help="Non-interactive way to set a key.")
put_parser.add_argument("--value", help="Non-interactive way to set a value.")
put_parser.set_defaults(fn=put)

# DEL
delete_parser = sub_parsers.add_parser("del", help="Delete a snippet by it's key")
delete_parser.add_argument("key")
delete_parser.set_defaults(fn=delete)

# LS
ls_parser = sub_parsers.add_parser("ls", help="See all stored snippets.")
ls_parser.set_defaults(fn=ls)

# RESET
reset_parser = sub_parsers.add_parser(
    "reset", help="Re-initialize the data-store. This will ERASE any currently stored data, use with care!"
)
reset_parser.set_defaults(fn=reset)


_echo_help(get_parser)
_echo_help(parser)
_echo_help(put_parser)
_echo_help(delete_parser)
_echo_help(ls_parser)
_echo_help(reset_parser)


if __name__ == "__main__":
    if not os.path.isdir(CONFIG_DIR):
        os.mkdir(CONFIG_DIR)

    if not os.path.exists(CONFIG):
        with open(CONFIG, "w") as config_file:
            config_file.write("[get]\ninterpolate_env_vars=True")

    args = sys.argv[1:]

    if len(args):
        if args[0] in {"ls", "put", "del", "reset", "-h", "--help"}:
            main_args = vars(parser.parse_args(args))
            fn = main_args.pop("fn")
            fn(**main_args)
            sys.exit()

        get_args = vars(get_parser.parse_args(args))
        get(**get_args)
        sys.exit()

    else:
        parser.print_help()
        sys.exit(1)
